# Yoach1 开发者实施指南

## 目录
- [系统架构概述](#系统架构概述)
- [核心模块说明](#核心模块说明)
- [关键数据流](#关键数据流)
- [代码实现示例](#代码实现示例)
- [常见问题与解决方案](#常见问题与解决方案)

---

## 系统架构概述

### 任务分配

| 任务名称 | 运行核心 | 优先级 | 栈大小 | 功能 |
|---------|---------|--------|--------|------|
| **TOFSensorTask** | Core 1 | 2 | 6144 | TOF传感器数据采集 |
| **ProcessingTask** | Core 0 | 2 | 4096 | 游戏逻辑处理 |
| **LightControlTask** | Core 0 | 3 | 2048 | LED灯光控制 |

### 互斥锁管理

```cpp
// 三个主要互斥锁
xSensorMutex        // 保护: hasTOFDetectionTask, sensorData
xObjectDetectedMutex // 保护: objectDetectedFlag
xLidarMutex         // 保护: TOF传感器数据访问
```

⚠️ **重要**: Bug #1和#2需要修复（见PRD_Critical_Bugs_Fix.md）

---

## 核心模块说明

### 1. BluetoothControl (蓝牙控制)

**文件**: `BluetoothControl.cpp`

**主要功能**:
- BLE服务初始化
- 消息接收和解析
- 通知发送

**关键代码**:
```cpp
// 消息回调处理
void MessageCallbacks::onWrite(BLECharacteristic *characteristic) {
    std::string data = characteristic->getValue();
    String dataStr = String(data.c_str());

    if (dataStr.length() > 0) {
        DATA.updateMsg(dataStr);  // 更新游戏数据
    }
}

// 发送通知
void BluetoothControl::sendMsgAndNotify(String msg) {
    pTxCharacteristic->setValue(msg.c_str());
    pTxCharacteristic->notify();
}
```

### 2. DataControl (数据管理)

**文件**: `DataControl.cpp`

**主要功能**:
- 游戏模式管理
- 参数存储
- 消息解析

**消息解析流程**:
```cpp
void DataControl::updateMsg(String data) {
    // 1. 解析模式ID
    int mode = data.substring(0, firstComma).toInt();

    // 2. 记录模式转换
    LOG_INFO(MODULE_DATA, "Mode transition: %s(%d) → %s(%d)",
             getModeName(gameMode), gameMode,
             getModeName(mode), mode);

    // 3. 根据模式解析参数
    switch (mode) {
        case RHYTHM_MODE:
            // 解析RGB和传感器参数
            setRedValue(...);
            setGreenValue(...);
            setBlueValue(...);
            break;
        default:
            // 解析标准参数
            setBlinkBreak(...);
            setTimedBreak(...);
            break;
    }
}
```

### 3. LightControl (灯光控制)

**文件**: `LightControl.cpp`

**颜色映射函数**:
```cpp
void LightControl::turn_on_RGB(int mode) {
    switch(mode) {
        case MANUAL_MODE:   manualWipe();  break;
        case RANDOM_MODE:   randomWipe();  break;
        case RHYTHM_MODE:   rhythmWipe();  break;
        case OPENING_MODE:  opening_light(); break;
        // ...
    }
}
```

**颜色变化检测**:
```cpp
void LightControl::manualWipe() {
    static int lastProcess = -1;
    static int lastLoggedMode = -1;

    bool shouldLog = (currentProcess != lastProcess) ||
                     (currentMode != lastLoggedMode);

    if (shouldLog) {
        // 记录颜色变化
        LOG_INFO(MODULE_LIGHT, "Manual Mode Color: %s", ...);
    }
}
```

### 4. TF_Luna_UART (TOF传感器)

**文件**: `TF_Luna_UART.cpp`

**检测逻辑**:
```cpp
bool TF_Luna_UART::detectObject() {
    // 1. 获取当前距离和振幅
    uint16_t currentAmp = getAmplitude();
    uint16_t currentDist = getDistance();

    // 2. 计算变化百分比
    float percentageDiff = ((float)currentAmp - baseline) / baseline * 100;

    // 3. 检测阈值
    if (percentageDiff > THRESHOLD) {
        objectDetected = true;
        return true;
    }
    return false;
}
```

---

## 关键数据流

### 1. BLE命令处理流程

```
移动App → BLE特征写入 → MessageCallbacks::onWrite()
    ↓
DATA.updateMsg() → 解析CSV → setGameMode()
    ↓
ProcessingTask → 检测模式变化 → 执行相应动作
    ↓
LIGHT.turnLightON() → turn_on_RGB() → 具体颜色函数
    ↓
BLE.sendMsgAndNotify() → 发送状态通知 → 移动App
```

### 2. 传感器检测流程

```
TOFSensorTask → 检查hasTOFDetectionTask标志
    ↓
TOF_SENSOR.updateLidarData() → 读取串口数据
    ↓
检测算法 → 设置objectDetected标志
    ↓
ProcessingTask → 检查objectDetected
    ↓
LIGHT.turnLightOff() → handleGameMode() → BLE通知
```

### 3. 模式转换状态机

```cpp
// main.cpp ProcessingTask
if (currentGameMode != prevGameMode) {
    switch (currentGameMode) {
        case OPENING_MODE:
            TOF_SENSOR.takeBaseline();  // 基线校准
            LIGHT.turnLightON();         // 开灯
            DATA.setGameMode(PROCESSED_MODE);
            break;

        case TERMINATE_MODE:
            LIGHT.turnLightOff();        // 关灯
            hasTOFDetectionTask = false; // 停止检测
            TOF_SENSOR.stopReading();    // 停止传感器
            break;
    }
}
```

---

## 代码实现示例

### 添加新游戏模式

1. **在Global_VAR.h定义模式ID**:
```cpp
#define NEW_MODE 7
```

2. **更新getModeName函数**:
```cpp
// DataControl.cpp 和 main.cpp
static const char* getModeName(int mode) {
    switch(mode) {
        case NEW_MODE: return "NEW";
        // ...
    }
}
```

3. **在LightControl中添加颜色函数**:
```cpp
void LightControl::newModeWipe() {
    // 实现颜色逻辑
    emit(colourCustom, 0, false, false);
}
```

4. **更新turn_on_RGB**:
```cpp
case NEW_MODE: newModeWipe(); break;
```

### 自定义颜色控制

```cpp
// 发送自定义RGB命令
void sendCustomColor(int r, int g, int b) {
    char cmd[64];
    sprintf(cmd, "5,%d,%d,%d,0,0,1,999", r, g, b);
    BLE.sendCommand(cmd);
}

// 渐变效果
void gradientEffect() {
    for (int i = 0; i < 256; i++) {
        sendCustomColor(i, 0, 255-i);  // 红到蓝渐变
        delay(10);
    }
}
```

### 传感器灵敏度调整

```cpp
// 修改TF_Luna_UART.h
#define AMPLITUDE_THRESHOLD_FACTOR 1.04f  // 降低到1.02提高灵敏度

// 或动态调整
void adjustSensitivity(float factor) {
    amplitudeThreshold = baseline_amplitude * factor;
}
```

---

## 常见问题与解决方案

### 问题1: 互斥锁使用错误

**现象**: 竞态条件导致传感器检测不稳定

**原因**: `hasTOFDetectionTask`使用了错误的互斥锁

**解决方案**:
```cpp
// 错误 ❌
if (takeMutexWithLogging(xObjectDetectedMutex, ...)) {
    hasTOFDetectionTask = false;
}

// 正确 ✅
if (takeMutexWithLogging(xSensorMutex, ...)) {
    hasTOFDetectionTask = false;
}
```

### 问题2: 死锁风险

**现象**: 系统无响应

**原因**: 使用`portMAX_DELAY`无限等待

**解决方案**:
```cpp
// 错误 ❌
xSemaphoreTake(xLidarMutex, portMAX_DELAY);

// 正确 ✅
if (xSemaphoreTake(xLidarMutex, pdMS_TO_TICKS(100)) == pdTRUE) {
    // 处理
    xSemaphoreGive(xLidarMutex);
} else {
    LOG_ERROR(MODULE_TOF, "Mutex timeout");
    return 0;  // 返回安全值
}
```

### 问题3: 颜色不更新

**现象**: 模式切换后颜色没变化

**原因**: 静态变量未重置

**解决方案**:
```cpp
// 添加模式变化检测
static int lastLoggedMode = -1;
bool shouldLog = (currentMode != lastLoggedMode);

if (shouldLog) {
    // 强制更新颜色
    lastLoggedMode = currentMode;
}
```

### 问题4: 内存溢出

**现象**: 系统崩溃或重启

**原因**: 动态内存分配或栈溢出

**解决方案**:
```cpp
// 避免使用String类 ❌
String dataStr = String(data.c_str());

// 使用固定缓冲区 ✅
char buffer[256];
strncpy(buffer, data.c_str(), sizeof(buffer)-1);
```

---

## 性能优化建议

### 1. 减少日志输出
```cpp
// 生产环境设置
Log.setMinimumLogLevel(LL_INFO);  // 不输出DEBUG
#define DEBUGGER 0                  // 关闭GPIO日志
```

### 2. 优化任务延时
```cpp
// 根据任务负载调整
vTaskDelay(shouldRunTask ? 1 : 10);  // 活跃时1ms，空闲时10ms
```

### 3. 批量处理传感器数据
```cpp
// 缓冲多个读数再处理
#define BUFFER_SIZE 10
uint16_t readings[BUFFER_SIZE];
// 收集数据后一次处理
```

### 4. 使用事件组代替轮询
```cpp
// 创建事件组
EventGroupHandle_t xEventGroup = xEventGroupCreate();

// 等待事件
EventBits_t bits = xEventGroupWaitBits(xEventGroup,
                                       SENSOR_EVENT_BIT,
                                       pdTRUE, pdFALSE,
                                       portMAX_DELAY);
```

---

## 测试检查清单

- [ ] 所有游戏模式切换正常
- [ ] 颜色显示与预期一致
- [ ] 传感器检测响应及时
- [ ] BLE连接稳定
- [ ] 无内存泄漏（运行24小时）
- [ ] 互斥锁无死锁
- [ ] 错误恢复机制正常
- [ ] 日志输出合理

---

## 调试技巧

### 1. 使用条件编译
```cpp
#if DEBUGGER
    LOG_INFO(MODULE_MAIN, "详细调试信息");
#endif
```

### 2. 添加断言
```cpp
configASSERT(mutex != NULL);
configASSERT(index < ARRAY_SIZE);
```

### 3. 监控栈使用
```cpp
UBaseType_t stackHighWaterMark = uxTaskGetStackHighWaterMark(NULL);
LOG_INFO(MODULE_MAIN, "Stack remaining: %d", stackHighWaterMark);
```

### 4. 使用串口命令
```cpp
// 添加调试命令处理
if (Serial.available()) {
    char cmd = Serial.read();
    switch(cmd) {
        case 'd': dumpStatus(); break;
        case 'r': esp_restart(); break;
    }
}
```

---

**文档版本**: 1.0 | **更新日期**: 2024-11-23